`define XLEN        64
`define PRF_LOG2    6
`define ROB_LOG2    5
`define RS          16
`define RS_LOG2     4

`define OLEN        16
`define PCLEN       32
`define WAYS        3

`define SD #1

typedef enum logic [4:0] {
	ALU_ADD     = 5'h00,
	ALU_SUB     = 5'h01,
	ALU_SLT     = 5'h02,
	ALU_SLTU    = 5'h03,
	ALU_AND     = 5'h04,
	ALU_OR      = 5'h05,
	ALU_XOR     = 5'h06,
	ALU_SLL     = 5'h07,
	ALU_SRL     = 5'h08,
	ALU_SRA     = 5'h09,
	ALU_MUL     = 5'h0a,
	ALU_MULH    = 5'h0b,
	ALU_MULHSU  = 5'h0c,
	ALU_MULHU   = 5'h0d,
	ALU_DIV     = 5'h0e,
	ALU_DIVU    = 5'h0f,
	ALU_REM     = 5'h10,
	ALU_REMU    = 5'h11
} ALU_FUNC;

module RS_Line(
    input                                       clock,
    input                                       reset,
    input                                       en,//able to output if ready

    input [`WAYS-1:0] [`XLEN-1:0]               CDB_Data,
    input [`WAYS-1:0] [`PRF_LOG2-1:0]           CDB_PRF_idx,
    input [`WAYS-1:0]                           CDB_valid,

    input [`XLEN-1:0]                           opa_in, // data or PRN
    input [`XLEN-1:0]                           opb_in, // data or PRN
    input                                       opa_valid, // indicate whether it is data or PRN, 1: data 0: PRN
    input                                       opb_valid,
    input                                       rd_mem_in,                          
    input                                       wr_mem_in,                           

    input                                       load_in, // high when dispatch
    input [`OLEN-1:0]                           offset_in,
    input [`PCLEN-1:0]                          PC_in,
    input ALU_FUNC                                    Operation_in, //
   // 
    input [`PRF_LOG2-1:0]                      dest_PRF_idx_in,
    input [`ROB_LOG2-1:0]                      rob_idx_in,

//    input INST_STRUCT               inst;

    output logic                                ready,
    output logic [`XLEN-1:0]                    opa_out,
    output logic [`XLEN-1:0]                    opb_out,
    output logic [`PRF_LOG2-1:0]                dest_PRF_idx,
    output logic [`ROB_LOG2-1:0]                rob_idx,
    output logic                                is_free,   

    output logic [`PCLEN-1:0]                   PC_out,
    output ALU_FUNC                                    Operation_out, // need to be updated
    output logic [`OLEN-1:0]                    offset_out,
    output logic                                rd_mem_out,                         
    output logic                                wr_mem_out                        


);
  logic [`XLEN-1:0]    opa,opb,next_opa,next_opb;
  logic                opa_is_valid,opb_is_valid,rd_mem,wr_mem,next_opa_valid,next_opb_valid;
  logic [`PRF_LOG2-1:0]   rs_dest_idx;
  logic [`ROB_LOG2-1:0]   rs_rob_idx;
  logic [`OLEN-1:0]    offset;
  logic [`PCLEN-1:0]   PC;
  ALU_FUNC            Operation;
  logic InUse;
  /*
  wire          LoadAFromCDB;  // signal to load from the CDB 
  wire          LoadBFromCDB;  // signal to load from the CDB 
*/

  assign ready=InUse&opa_is_valid&opb_is_valid;
  assign is_free=~InUse;
  assign opa_out=(en&ready)?opa:`XLEN'b0;
  assign opb_out=(en&ready)?opb:`XLEN'b0;
  assign dest_PRF_idx=(en&ready)?rs_dest_idx:`PRF_LOG2'b0;
  assign rob_idx=(en&ready)?rs_rob_idx:`ROB_LOG2'b0;
  assign PC_out=(en&ready)?PC:`PCLEN'b0;
  assign offset_out=(en&ready)?offset:`OLEN'b0;
  assign Operation_out=(en&ready)?Operation:5'b0;
  assign rd_mem_out=(en&ready)?rd_mem:1'b0;
  assign wr_mem_out=(en&ready)?wr_mem:1'b0;
/*
  assign LoadAFromCDB = (CDB_PRF_idx == opa) && CDB_valid && !opa_is_valid && InUse ; 
  assign LoadBFromCDB = (CDB_PRF_idx == opb) && CDB_valid && !opb_is_valid && InUse ;
*/

//integer i,j;
always_comb 
begin
next_opa=opa;
next_opa_valid=opa_is_valid;
   if(!opa_is_valid && InUse)begin
  // genvar i
  // generate
     for(int i=0;i<`WAYS;i=i+1)
     begin//:cdba
        if((CDB_PRF_idx[i]==opa)&&CDB_valid[i])begin
        next_opa=CDB_Data[i];
        next_opa_valid=1'b1;
        end
     end
   //end generate  
   end
end

always_comb 
begin
next_opb=opb;
next_opb_valid=opb_is_valid;
   if(!opb_is_valid && InUse)begin
  // genvar j
 //  generate
     for(int j=0;j<`WAYS;j=j+1)
     begin//:cdbb
        if((CDB_PRF_idx[j]==opb)&&CDB_valid[j])begin
        next_opb=CDB_Data[j];
        next_opb_valid=1'b1;
        end
     end
 //  end generate  
   end
end


always @(posedge clock) 
begin 
    if (reset) 
    begin 
            opa <= `SD 0; 
            opb <= `SD 0; 
            opa_is_valid <= `SD 0; 
            opb_is_valid <= `SD 0; 
            rd_mem <= `SD 0;
            wr_mem <= `SD 0;
            rs_dest_idx <= `SD 0;
            rs_rob_idx <= `SD 0;
            offset <= `SD 0;
            PC <= `SD 0;
            Operation <= `SD 0;
            InUse <= `SD 1'b0;     
    end 
    else 
    begin 
        if (load_in) 
        begin 
            opa <= `SD opa_in; 
            opb <= `SD opb_in; 
            opa_is_valid <= `SD opa_valid; 
            opb_is_valid <= `SD opb_valid; 
            rd_mem <= `SD rd_mem_in;
            wr_mem <= `SD wr_mem_in;
            rs_dest_idx <= `SD dest_PRF_idx_in;
            rs_rob_idx <= `SD rob_idx_in;
            offset <= `SD offset_in;
            PC <= `SD PC_in;
            Operation <= `SD Operation_in;
            InUse <= `SD 1'b1; 
        end 
        else 
        begin
        opa <= `SD next_opa;
        opa_is_valid <= `SD next_opa_valid;
        opb <= `SD next_opb;
        opb_is_valid <= `SD next_opb_valid;
        
        /*
            if (LoadAFromCDB)
            begin
                opa <= `SD CDB_Data;
                opa_is_valid <= `SD 1'b1;
            end
            if (LoadBFromCDB)
            begin
                opb <= `SD CDB_Data;
                opb_is_valid <= `SD 1'b1;
            end
        */
            // Clear InUse bit once the FU has data
            if (en&ready)
            begin
                InUse <= `SD 1'b0;
            end
        end 
    end 
end 
    
endmodule


module RS(
    input                                       clock,
    input                                       reset,

    input [`WAYS-1:0] [`XLEN-1:0]               CDB_Data,
    input [`WAYS-1:0] [`PRF_LOG2-1:0]           CDB_PRF_idx,
    input [`WAYS-1:0]                           CDB_valid,

    input [`WAYS-1:0] [`XLEN-1:0]               opa_in, // data or PRN
    input [`WAYS-1:0] [`XLEN-1:0]               opb_in, // data or PRN
    input [`WAYS-1:0]                           opa_valid, // indicate whether it is data or PRN, 1: data 0: PRN
    input [`WAYS-1:0]                           opb_valid,
    input [`WAYS-1:0]                           rd_mem_in,                          
    input [`WAYS-1:0]                           wr_mem_in,                           


    input                                       load_in, // high when dispatch
    input [`WAYS-1:0] [`OLEN-1:0]               offset_in,
    input [`WAYS-1:0] [`PCLEN-1:0]              PC_in,
    input [`WAYS-1:0] [4:0]                     Operation_in, // need to be updated
    input [`WAYS-1:0] [`PRF_LOG2-1:0]                dest_PRF_idx_in,
    input [`WAYS-1:0] [`ROB_LOG2-1:0]                rob_idx_in,

//    input INST_STRUCT               inst;
    output logic [`WAYS-1:0]                    inst_out_valid, // !!!tell which inst is valid, 100 when only one inst is valid 
    output logic [`WAYS-1:0] [`XLEN-1:0]        opa_out,
    output logic [`WAYS-1:0] [`XLEN-1:0]        opb_out,
    output logic [`WAYS-1:0] [`PRF_LOG2-1:0]    dest_PRF_idx,
    output logic [`WAYS-1:0] [`ROB_LOG2-1:0]    rob_idx,

    output logic [`WAYS-1:0] [`PCLEN-1:0]       PC_out,
    output logic [`WAYS-1:0] [4:0]              Operation_out, 
    output logic [`WAYS-1:0] [`OLEN-1:0]        offset_out,
    output logic [`RS_LOG2-1:0]                 num_is_free, //!!! 
    
    output logic [`WAYS-1:0]                    rd_mem_out,                          
    output logic [`WAYS-1:0]                    wr_mem_out                          

);

//input for all , selected `WAY equal to rs input
    wire [`RS-1:0] [`XLEN-1:0]               lines_opa_in; // data or PRN
    wire [`RS-1:0] [`XLEN-1:0]               lines_opb_in; // data or PRN
    wire [`RS-1:0]                           lines_opa_valid; // indicate whether it is data or PRN, 1: data 0: PRN
    wire [`RS-1:0]                           lines_opb_valid;
    wire [`RS-1:0]                           lines_rd_mem_in;                          
    wire [`RS-1:0]                           lines_wr_mem_in;                           
    wire [`RS-1:0] [`OLEN-1:0]               lines_offset_in;
    wire [`RS-1:0] [`PCLEN-1:0]              lines_PC_in;
    wire [`RS-1:0] [4:0]                     lines_Operation_in; // need to be updated
    wire [`RS-1:0] [`PRF_LOG2-1:0]                lines_dest_PRF_idx_in;
    wire [`RS-1:0] [`ROB_LOG2-1:0]                lines_rob_idx_in;

//output for all , selected `WAY equal to rs output
    wire [`RS-1:0] [`XLEN-1:0]        lines_opa_out;
    wire [`RS-1:0] [`XLEN-1:0]        lines_opb_out;
    wire [`RS-1:0] [`PRF_LOG2-1:0]    lines_dest_PRF_idx;
    wire [`RS-1:0] [`ROB_LOG2-1:0]    lines_rob_idx;
    wire [`RS-1:0] [`PCLEN-1:0]       lines_PC_out;
    wire [`RS-1:0] [4:0]              lines_Operation_out; 
    wire [`RS-1:0] [`OLEN-1:0]        lines_offset_out;  
    wire [`RS-1:0]                    lines_rd_mem_out;                          
    wire [`RS-1:0]                    lines_wr_mem_out;        

    logic [`RS-1:0] lines_free,lines_ready; 
    logic [`RS-1:0] lines_en,lines_load; 
  // ps #(.NUM_BITS(`RS)) in(.req(lines_free), .en(1'b1), .gnt(lines_load), .req_up()); 
   // ps #(.NUM_BITS(`RS)) out(.req(lines_ready), .en(1'b1), .gnt(lines_en), .req_up()); 

integer j;
integer in=`WAYS-1;
integer out=`WAYS-1;
always_comb begin
inst_out_valid=`WAYS'b0;
for(j=0;j<`RS;j=j+1) 
    lines_en[j]=0;
    lines_opa_in[j]=0;
    lines_opb_in[j]=0;
    lines_opa_valid[j]=0;
    lines_opb_valid[j]=0;
    lines_rd_mem_in[j]=0;
    lines_wr_mem_in[j]=0;
    lines_load[j]=0;
    lines_offset_in[j]=0;
    lines_PC_in[j]=0;
    lines_Operation_in[j]=0;
    lines_dest_PRF_idx_in[j]=0;
    lines_rob_idx_in[j]=0;
    if(lines_ready[j]&&(out>-1))begin //en=1 output this line to [out]  output to significant bits first
    lines_en[j]=1;
/*
    opa_out[out]=lines_opa_out[j];
    opb_out[out]=lines_opb_out[j];
    dest_PRF_idx[out]=lines_dest_PRF_idx[j];
    rob_idx[out]=lines_rob_idx[j];
    PC_out[out]=lines_PC_out[j];
    Operation_out[out]=lines_Operation_out[j];
    offset_out[out]=lines_offset_out[j];
    rd_mem_out[out]=lines_rd_mem_out[j];
    wr_mem_out[out]=lines_wr_mem_out[j];
*/  
    inst_out_valid[out]=1;
    out=out-1;
    num_is_free=num_is_free+1;
    end
    if(lines_free[j]&&(in>-1))begin //load=1 input [in] into this line input from significant bits first
    //Question: if input lines less than `WAY?
    lines_load[j]=1;
    lines_opa_in[j]=opa_in[in];
    lines_opb_in[j]=opb_in[in];
    lines_opa_valid[j]=opa_valid[in];
    lines_opb_valid[j]=opb_valid[in];
    lines_rd_mem_in[j]=rd_mem_in[in];
    lines_wr_mem_in[j]=wr_mem_in[in];
    lines_offset_in[j]=offset_in[in];
    lines_PC_in[j]=PC_in[in];
    lines_Operation_in[j]=Operation_in[in];
    lines_dest_PRF_idx_in[j]=dest_PRF_idx_in[in];
    lines_rob_idx_in[j]=rob_idx_in[in];
    in=in-1;
    num_is_free=num_is_free-1;
    end
end


genvar i;
generate 
for (i=0;i<`RS;i=i+1) begin: rslines
RS_Line rs_line(
     .clock(clock),
     .reset(reset),
     .en(lines_en[i]), // need to select `WAY among all is ready------
     .CDB_Data(CDB_Data),
     .CDB_PRF_idx(CDB_PRF_idx),
     .CDB_valid(CDB_valid),
     .opa_in(lines_opa_in[i]), //input if selected (start)
     .opb_in(lines_opb_in[i]),
     .opa_valid(lines_opa_valid[i]),
     .opb_valid(lines_opb_valid[i]),
     .rd_mem_in(lines_rd_mem_in[i]),
     .wr_mem_in(lines_wr_mem_in[i]),
     .load_in(lines_load[i]), //need to select `WAY among all is_free-----
     .offset_in(lines_offset_in[i]),
     .PC_in(lines_PC_in[i]),
     .Operation_in(lines_Operation_in[i]),
     .dest_PRF_idx_in(lines_dest_PRF_idx_in[i]),
     .rob_idx_in(lines_rob_idx_in[i]), //input if selected (end)
     .ready(lines_ready[i]), //used for selection of en------
     .opa_out(lines_opa_out[i]), //output if en&ready (start)
     .opb_out(lines_opb_out[i]),
     .dest_PRF_idx(lines_dest_PRF_idx[i]),
     .rob_idx(lines_rob_idx[i]),
     .is_free(lines_free[i]),//used for selection----
     .PC_out(lines_PC_out[i]),
     .Operation_out(lines_Operation_out[i]),
     .offset_out(lines_offset_out[i]),
     .rd_mem_out(lines_rd_mem_out[i]),
     .wr_mem_out(lines_wr_mem_out[i])    //output (end)               
);
end
endgenerate

always_comb begin
out=`WAYS-1;
//inst_out_valid=`WAYS'b0;
for(j=0;j<`RS;j=j+1)  
    if(lines_ready[j]&&lines_en[j])begin //en=1 output this line to [out]  output to significant bits first
    opa_out[out]=lines_opa_out[j];
    opb_out[out]=lines_opb_out[j];
    dest_PRF_idx[out]=lines_dest_PRF_idx[j];
    rob_idx[out]=lines_rob_idx[j];
    PC_out[out]=lines_PC_out[j];
    Operation_out[out]=lines_Operation_out[j];
    offset_out[out]=lines_offset_out[j];
    rd_mem_out[out]=lines_rd_mem_out[j];
    wr_mem_out[out]=lines_wr_mem_out[j];
    out=out-1;
    end
end



endmodule
